#Gitlet Project Design Document

Author: Yi Zhang

Last update: 2020/4/17



###Classes and Data Structure

- ####Main

The driver class for the Gitlet version control system.



- ####Command

A superclass defined for all types of commands. Each child of this class (a specific command) can have its own fields and methods if necessary. The subclasses of the Command class are the Init class, Add class etc. 

#####Fields

1. String _type: A string representation of the name of command
2. String _args: A string representation of the operands (if any)



- #### Check

The class that contains methods for checking arguments. Different commands will have corresponding check method. The command that has no failure case will not have a check method.



- ####Commit

This is the class that stores the information of commit.

#####Fields

1. String _logMsg: A brief description of the commit
2. Date _time: Time to make the commit
3. String _par1: A reference to parent commit 1
4. String _par2: A reference to parent commit 2
5. String _shaID: An integer id to refer to the commit
6. HashMap _blobMap: A mapping that maps a file name to its unique reference (hash value generated by the SHA-1)



- #### StageAdd

This class helps to store the file that is staged for adding

##### Fields

1. HashMap _files: A HashMap that maps file name to its SHA-1 reference



- #### StageDelete

This class helps to store the file that is staged for delete

##### Fields

1. HashMap _files: A HashMap that maps file name to its SHA-1 reference



- ####GitletException

A general-purpose error-reporting exception for the Gitlet project package. All anticipated user or I/O errors should be reported through this exception. (all error messages end with a period)



- ####Utils

A class containing useful functions to deal with file and persisting.

<div style="page-break-after: always;"></div>



###Algorithms

Note: for subclass of command class, this part of document only describes the methods that are not in superclass or that are overwritten. 

- #### StageAdd Class

1. StageAdd()

   The class constructor. It initialize the _file field as a new HashMap.

2. put(String filename, String hashValue)

   Put the mapping of a file to its hashcode into the HashMap, which means it is staged.

3. remove(String filename, String hashValue)

   Remove the mapping of a file to its hashcode from the HashMap, which means the file is not longer being staged.



- #### StageRemove Class

1. StageRemove()

   The class constructor. It initialize the _file field as a new HashMap.

2. put(String filename, String hashValue)

   Put the mapping of a file to its hashcode into the HashMap, which means it is staged.

3. remove(String filename, String hashValue)

   Remove the mapping of a file to its hashcode from the HashMap, which means the file is not longer being staged.



- #### Check Class

1. initCheck(String... args)
2. addCheck(String... args)
3. commitCheck(String... args)
4. logCheck(String... args)
5. Check(String... args)



- #### Command Class

1. Command(String type, String[] operands)

   The empty class constructor.

3. execute()

   Empty void method, which will be overwritten based on the specific purpose of the specific command.

4. type()

   Return the string representation of the type of the command.



- ####Init Class

1. Command(String type, String[] operands)

   The class constructor. operands will be set to null in this case.

3. execute()

   Initialize a new Gitlet version control system. Meanwhile, this command will also create a initial commit, which will contain a log message "initial commit", with no files and a single branch called "master". The timestamp for this initial commit will be 00:00:00 UTC, Thursday, 1 January 1970. Additionally, it will create a .gitlet directory to store information. It will have subdirectories such as stage (which contains files that are staged), commits (which contains all the commits.) 

   

- ####Commit Class

1. Commit()

   The class constructor. It will perform an "initial commit", which will be executed when we initialize a Gitlet version control system. If there already exists a Gitlet system, it will report a Gitlet exception error.

2. Commit(String logMsg, Date time, Commit par1, Commit par2, String shaID, HashMap, blobMap)

   The class constructor for normal commit. Save the log, timestamp, parent, ID and a hashmap for a specific log. If there is only one parent, set par2 to be null

3. put(String filename, String hashValue)

   Put the mapping of a file to its hashcode into the HashMap for files that is staged for addition and were not tracked by the parent commit.

4. remove(String filename, String hashValue)

   Remove the mapping of a file to its hashcode from the HashMap if the file is being staged for removal.

5. execute()

   Execute the commit command. Write the new commit into related directory in .gitlet. Clean the staging area. Change the head pointer to point to the current commit. 

   


- #### Add Class

2. execute()

   Add the file into the staging area if it is not in the staging area. If the file is already in the staging area and is different from the current commit, it will overwrite the original content. But if the contents are the same, then remove it from the area.



- #### Rm Class

1. check(String... args)

   If the file is not in the staging area or is not tracked by the head commit, print out the error message and return false. Otherwise, return true.

2. execute()

   Use remove method to remove the file from the HashMap if the file is currently staged. If the file is tracked in the current commit, stage it for removal and remove the file from the working directory if the user has not already done so.



- #### Log Class

1. printLog(Commit c)

   Print out the information incorporated in the commit c in the indicated format.

2. execute()

   Use readObject to read the header of CTree. Every time we visit a node, use printLog function to print the message. We go backward based on the first parent until we reach the root of the tree.



- #### GlobalLog Class

1. printLog(Commit c)

   The same as the one in Log class

2. execute()

   To simplify the algorithm, we start from the initial commit. For every node(commit) we vistit, use printLog function to print the information. Then use preorder traversal to visit the whole tree.



- #### Find Class

1. execute()

   Start from the root of commit tree, traversal the whole tree. Every time we visit a node, check whether the log message is the same as the given one. If so, output the id of that commit. If we did not find any matched commit, print the error message.



- ####Status Class

1. execute()

   Check the .gitlet directory to see whether there are multiple branches. Print all the branches in the indicated format. Use readObeject in the stageAdd directory and stageRemove directory to get the file for addition and removal. Print them in format. In addition, examine all the files in the working directory to see if it is modified but not staged or if it is untracked.



- ####Checkout Class

1. 









<div style="page-break-after: always;"></div>

###Persistence

- #### Structure of .gitlet directory

The .gitlet directory will contain the following: 

1. stageAdd directory: used for storing files that are staged for adding
2. stageRemove directory: used for storing files that are staged for removal
3. commits directory: used to storing the commit tree (this directory will have 2 subdirectories if we have 2 branches)
4. head directory: a subdirectory of commits (commits/head), used to store the head commit







- ####Strategy for Persisting

In order to keep track of different states of our program, everytime we use add command, rm command etc, we modify the stage directory using function writeObject provided in the Utils.java class. Similarly, everytime we execute the commit command, we add the new commit node into the commit tree and use the writeObject function to write it in the commits directory.

If we need information in these directories, we can use readObject function to read. For example, in add command, we need information from the current commit, which is essentially the (active) leaf of the current branch. We can use readObject to read in the tree and use function in CTree to get the latest commit.

